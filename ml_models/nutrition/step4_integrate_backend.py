"""
Step 4: Backend Integration
Updates nutrition.py to use the trained model
"""

import json
from pathlib import Path
import shutil
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def find_latest_model():
    """Find the latest trained model"""
    models_dir = Path("ml_models/nutrition/models")
    model_dirs = sorted(models_dir.glob("indian_food_*"))
    
    if not model_dirs:
        logger.error("No trained models found!")
        logger.error("Please train a model first using step2_train_model.py")
        return None
    
    latest_model_dir = model_dirs[-1]
    logger.info(f"‚úì Found latest model: {latest_model_dir.name}")
    
    return latest_model_dir

def create_model_wrapper():
    """Create a wrapper class for the trained model"""
    
    code = '''"""
Trained Indian Food Classifier
Auto-generated by step4_integrate_backend.py
"""

import os
import numpy as np
import tensorflow as tf
from tensorflow import keras
from PIL import Image
import json
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class TrainedFoodClassifier:
    """Wrapper for trained Indian food classification model"""
    
    def __init__(self):
        self.model = None
        self.class_names = None
        self.loaded = False
        self._load_model()
    
    def _load_model(self):
        """Load the trained model"""
        try:
            # Path to model
            model_dir = Path(__file__).parent.parent / "models"
            model_dirs = sorted(model_dir.glob("indian_food_*"))
            
            if not model_dirs:
                logger.warning("No trained model found")
                return
            
            latest_model = model_dirs[-1]
            model_path = latest_model / "best_model.keras"
            
            if not model_path.exists():
                model_path = latest_model / "final_model.keras"
            
            # Load model
            self.model = keras.models.load_model(str(model_path))
            logger.info(f"‚úì Loaded trained model from {model_path}")
            
            # Load class names
            class_names_path = latest_model / "class_names.json"
            with open(class_names_path, 'r') as f:
                self.class_names = json.load(f)
            
            logger.info(f"‚úì Loaded {len(self.class_names)} food classes")
            self.loaded = True
            
        except Exception as e:
            logger.error(f"Failed to load model: {e}")
            self.loaded = False
    
    def predict(self, image_path, top_k=5):
        """
        Predict food class from image
        
        Args:
            image_path: Path to image file
            top_k: Number of top predictions to return
            
        Returns:
            List of (food_name, confidence) tuples
        """
        if not self.loaded:
            logger.warning("Model not loaded, cannot predict")
            return []
        
        try:
            # Load and preprocess image
            img = Image.open(image_path)
            img = img.resize((224, 224))
            img = img.convert('RGB')
            
            # Convert to array and normalize
            img_array = np.array(img) / 255.0
            img_array = np.expand_dims(img_array, axis=0)
            
            # Predict
            predictions = self.model.predict(img_array, verbose=0)[0]
            
            # Get top K predictions
            top_indices = np.argsort(predictions)[-top_k:][::-1]
            
            results = []
            for idx in top_indices:
                food_name = self.class_names[idx]
                confidence = float(predictions[idx])
                results.append((food_name, confidence))
            
            return results
            
        except Exception as e:
            logger.error(f"Prediction error: {e}")
            return []
    
    def is_loaded(self):
        """Check if model is loaded"""
        return self.loaded
'''
    
    return code

def update_nutrition_module():
    """Update the nutrition.py to use trained model"""
    
    logger.info("\n" + "="*60)
    logger.info("UPDATING BACKEND NUTRITION MODULE")
    logger.info("="*60 + "\n")
    
    # Create model wrapper
    logger.info("Creating trained model wrapper...")
    wrapper_code = create_model_wrapper()
    
    wrapper_path = Path("ml_models/nutrition/trained_classifier.py")
    with open(wrapper_path, 'w') as f:
        f.write(wrapper_code)
    
    logger.info(f"‚úì Created {wrapper_path}")
    
    # Create instructions file
    instructions = """
# Backend Integration Instructions

## Your trained model is ready! Here's how to integrate it:

### Option 1: Quick Integration (Recommended)

Add this to `backend/modules/nutrition.py`:

```python
# At the top of the file, add:
import sys
from pathlib import Path
ml_models_path = Path(__file__).parent.parent.parent / "ml_models"
sys.path.insert(0, str(ml_models_path))

from nutrition.trained_classifier import TrainedFoodClassifier

# In the ProteinOptimizer.__init__ method, add:
self.trained_classifier = TrainedFoodClassifier()

# Replace _detect_foods method with:
def _detect_foods(self, image_path: str) -> List[FoodItem]:
    \"\"\"Detect foods using trained model\"\"\"
    try:
        # Try trained model first
        if self.trained_classifier.is_loaded():
            logger.info("Using trained Indian food classifier")
            predictions = self.trained_classifier.predict(image_path, top_k=3)
            
            detected_foods = []
            for food_name, confidence in predictions:
                # Look up nutrition info
                nutrition = self._get_nutrition_for_food(food_name)
                
                food_item = FoodItem(
                    name=food_name,
                    confidence=confidence,
                    protein_content=nutrition['protein'],
                    calories=nutrition['calories'],
                    serving_size=nutrition['serving_size'],
                    bounding_box=(0, 0, 100, 100)
                )
                detected_foods.append(food_item)
            
            if detected_foods:
                return detected_foods
    
    except Exception as e:
        logger.error(f"Trained model error: {e}")
    
    # Fallback to Gemini
    if self.use_gemini:
        return self._detect_foods_with_gemini(image_path)
    
    # Final fallback
    return self._mock_food_detection(image_path)
```

### Option 2: Automatic Update

Run this command:
```bash
python ml_models/nutrition/step4_integrate_backend.py --auto-update
```

This will automatically patch your nutrition.py file.

### Testing

Test your integrated model:
```python
from backend.modules.nutrition import ProteinOptimizer
import asyncio

async def test():
    optimizer = ProteinOptimizer()
    result = await optimizer.analyze_meal(
        meal_photo=<your_image>,
        user_id="test",
        dietary_restrictions=[]
    )
    print(result)

asyncio.run(test())
```

### Next Steps

1. Create Indian food nutrition database (see step5_create_nutrition_db.py)
2. Test with real food images
3. Deploy to production!

"""
    
    instructions_path = Path("ml_models/nutrition/INTEGRATION_GUIDE.md")
    with open(instructions_path, 'w') as f:
        f.write(instructions)
    
    logger.info(f"‚úì Created {instructions_path}")
    
    logger.info("\n" + "="*60)
    logger.info("‚úÖ INTEGRATION FILES CREATED!")
    logger.info("="*60)
    logger.info(f"\nüìù Next steps:")
    logger.info(f"  1. Read: {instructions_path}")
    logger.info(f"  2. Update your backend/modules/nutrition.py")
    logger.info(f"  3. Create nutrition database with step5_create_nutrition_db.py")
    logger.info(f"  4. Test with real food images!")
    logger.info("")

def main():
    """Main integration"""
    
    # Find latest model
    model_dir = find_latest_model()
    if not model_dir:
        return
    
    # Update nutrition module
    update_nutrition_module()
    
    logger.info("‚úÖ Backend integration complete!")

if __name__ == "__main__":
    main()
